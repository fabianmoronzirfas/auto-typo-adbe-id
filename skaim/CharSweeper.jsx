//////////////////////////////////////   "CharSweeper" by Sebastian Kaim ///////////////////////////////////////////   This script creates a matrix with random characters. /////   Characters included in your first name will be highlighted as well as their surrounding characters./////////////////////////////////main();function main (){    //////////////////////////////////////    MAKE IT YOUR WAY!///                                ///     var density = 11 ;            /// >> The variable "density" defines how many and how big characters will be displayed. ///                                ///    Choose a lower value to decrease the number of characters (= bigger Fontsize) and vice versa. ////////////////////////////////////////////////////////////////////////////    ATTENTION! WARNING! ///                                ///var myfont = app.fonts.item(988);  /// >> The variable "myfont" defines the font of the displayed characters. ///                                ///    Use any font, preferably a monospoace-font and insert its "number". //////////////////////////////////////    To get the "numbers" of all your installed fonts see this script by @fabiantheblind: https://github.com/fabiantheblind/auto-typo-adbe-id/wiki/Fonts                                          //Add a new document with 200 x 200 mm in size.var doc = app.documents.add({         documentPreferences:{            pageHeight:200,            pageWidth:200,            facingPages:false                    }});// Get to know the user's first name.var name_temp = prompt("What's your first name?" ,"Type here...");// If the user doesn't insert a name, abort the script.if (name_temp == null){    app.activeDocument.close(SaveOptions.NO);     return;}// Otherwise, transform all characters of the name into capital letters.var name = name_temp.toUpperCase();// Prepare an array for the name's single characters.var namearr = new Array(); // Split the first name into its characters and store them in the "textarr" array.for (var i = 0; i < name.length; i++){    namearr[i]=name.charAt(i);     }// Define some variables for easier use in the following for-loops.var pw = doc.documentPreferences.pageWidth;var ph = doc.documentPreferences.pageHeight;var page = doc.pages.item(0);// Make sure, all objects including textframes have their reference/anchor point in the center. // This is needed to flip characters while staying on their designated position.app.activeWindow.transformReferencePoint = AnchorPoint.CENTER_ANCHOR;// Create a matrix spanning the whole canvas and fill it with random characters var matrix = new Array(); //This array will contain the rowsfor (var y = 0; y < density; y++){    var rows = new Array(); //Rows will contain the textframes with the characters        for (var x = 0; x < density; x++){                        // Define, how characters are displayed.                var tf = page.textFrames.add({  // Add a Textframe                     geometricBounds:[0+ph/density*y,0+pw/density*x,(1+y)*ph/density,(1+x)*pw/density], // The size is dependent on the chosen value of "density"                     contents: charselect(), // Fill it with a random character >> see the charselect-function below for more information.                     fillColor: doc.swatches.item(6), //Color the character white.                     });            tf.paragraphs[0].appliedFont = myfont; // Apply the font chosen at the beginning of the script            tf.paragraphs[0].fillColor = doc.swatches.item(2); // Make the background yellow.            tf.paragraphs[0].justification = Justification.CENTER_ALIGN; // Align the character to the center.                        // Mirror random characters horizontally.                        if (Math.round(Math.random()*2) > 1){                tf.flip = Flip.HORIZONTAL;                                 }                         // Adjust the font-size to fit the designated size of the textframe (--> density). Credits to @fabiantheblind                        var ptsize = tf.paragraphs[0].pointSize; // current point size of character                        while (tf.overflows == false){                    ptsize++;                    tf.paragraphs[0].pointSize = ptsize;            }            while (tf.overflows == true){                    ptsize--;                    tf.paragraphs[0].pointSize = ptsize;            }            // If the randomly chosen character is part of the user's name, make it black and make sure, it wasn't mirrored.                for (var i = 0; i < namearr.length; i++){                if (tf.contents == namearr[i]){                    tf.paragraphs[0].fillColor = doc.swatches.item(3);                    tf.flip = Flip.NONE;                }                }            // Add the created textframe with the character to the row currently builded.                        rows.push(tf);    }        // When the whole row is filled with characters, add it to the matrix and start over again with another row.        matrix.push(rows);} // Neighboring characters of the black characters should be gray// Here is how:// Create a new color for neighbors.var my_color = doc.colors.add();my_color.model = ColorModel.PROCESS;my_color.space = ColorSpace.RGB;my_color.colorValue = [150,150,150]; // This is gray// Identify all textframes with black characters (= the name's characters) and adjust their neighbors on top/bottom/left/right.// Crawl through the matrix:for (var x = 0; x < density; x++){        for (var y = 0; y < density ; y++){                                    if( matrix[y][x].paragraphs[0].fillColor == doc.swatches.item(3)){    // identify all black characters                                      var count = 0; // A variable to break off the while-loop after one iteration.                                      while (x != 0 && count <1 ){ // There is no left neighbor, if the textframe is at the very left.                        matrix[y][x-1].paragraphs[0].fillColor = doc.swatches.item(10); //color the neighbor on the left gray                        matrix[y][x-1].flip = Flip.NONE;  // make sure, the character is not mirrored.                                               count++;}                               count = 0;                                        while (x != density-1 && count <1){ //The same for the right side                        matrix[y][x+1].paragraphs[0].fillColor = doc.swatches.item(10);                         matrix[y][x+1].flip = Flip.NONE;                        count++;}                        count = 0;                                     while (y != 0 && count <1){ // The same for the neighbor underneath                        matrix[y-1][x].paragraphs[0].fillColor = doc.swatches.item(10);                         matrix[y-1][x].flip = Flip.NONE;                        count++;}                    count = 0;                                        while (y != density-1 && count <1){ //And finally the neighbor above                        matrix[y+1][x].paragraphs[0].fillColor = doc.swatches.item(10);                         matrix[y+1][x].flip = Flip.NONE;                        count++;}                     }           }}//Make sure that characters included in the name are always black even if two of them ly next to each otherfor (var y = 0; y < density; y++){        for (var x = 0; x < density ; x++){            if( matrix[x][y].paragraphs[0].fillColor == doc.swatches.item(3)){                matrix[x][y].paragraphs[0].fillTint = 100;                }        }}// This function selects a random character of the alphabet (including digits)function charselect(){    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";  //Adjust this string to change the base for the randomly chosen characters    var chars_arr = new Array();    for (var i = 0; i < chars.length; i++){        chars_arr[i]=chars.charAt(i);         }    var char_sel = chars_arr[parseInt(Math.random()*chars.length)];    return char_sel;    }    }